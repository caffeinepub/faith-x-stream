{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Implement synchronized Live TV playback with server-side time tracking",
  "requirements": [
    {
      "id": "REQ-41",
      "summary": "Build a new LiveTVSyncPlayer component that fetches server-side synchronization data and seeks the video element to match server-calculated position",
      "acceptanceCriteria": [
        "New LiveTVSyncPlayer component exists alongside existing VideoPlayer",
        "Component polls sync endpoint at regular intervals (5-10 seconds)",
        "Video element seeks to server-provided position when drift exceeds 2-3 seconds",
        "Existing VideoPlayer remains unchanged for VOD playback"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/LiveTVSyncPlayer.tsx",
          "operation": "create",
          "description": "Create a new LiveTVSyncPlayer component separate from VideoPlayer that manages synchronized live TV playback. Implement video player with custom controls similar to VideoPlayer but focused on live TV synchronization. Include polling mechanism using setInterval to fetch sync data from getDynamicLiveChannelState every 5-10 seconds. Store sync data in component state (currentProgramId, playbackPosition, serverTime, isLooping). Render video element with ref for direct manipulation. Include basic controls (play/pause, volume, fullscreen) but disable seek controls for live content. Use the backend's LiveChannelState type to structure sync data handling."
        }
      ]
    },
    {
      "id": "REQ-42",
      "summary": "Implement drift detection and correction in LiveTVSyncPlayer by comparing video currentTime with server-calculated position",
      "acceptanceCriteria": [
        "Drift is measured by comparing video.currentTime with server position plus elapsed time since last sync",
        "Seek correction only triggers when drift exceeds threshold (avoid constant seeking)",
        "Player handles buffering and network delays gracefully without excessive seeking"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/LiveTVSyncPlayer.tsx",
          "operation": "modify",
          "description": "Add drift detection logic within the sync polling mechanism. Calculate expected position as: serverPlaybackPosition + (Date.now() - lastSyncTime) / 1000. Compare video.currentTime with expected position. If absolute difference exceeds 2-3 second threshold and video is not buffering (readyState >= 3), execute videoRef.current.currentTime = expectedPosition to correct drift. Implement debouncing to prevent seek thrashing during buffering. Track lastSeekTime to avoid seeking more than once per polling interval. Add state for tracking drift amount for potential UI display."
        }
      ]
    },
    {
      "id": "REQ-43",
      "summary": "Update LivePage to use the new LiveTVSyncPlayer component for channel playback instead of VideoPlayer",
      "acceptanceCriteria": [
        "LivePage renders LiveTVSyncPlayer for Live TV channel playback",
        "Channel selection, EPG grid, and surfing behavior remain unchanged",
        "Switching channels triggers sync data fetch and position calculation for new channel",
        "VOD content (if any) still uses existing VideoPlayer"
      ],
      "file_operations": [
        {
          "path": "frontend/src/pages/LivePage.tsx",
          "operation": "modify",
          "description": "Replace the existing VideoPlayer component usage with conditional rendering: if selectedChannel exists, render LiveTVSyncPlayer with channelId prop; otherwise keep existing fallback UI. Pass selectedChannel.id to LiveTVSyncPlayer. Preserve all existing LivePage state management (selectedChannel, showGuide) and user interactions (channel selection from guide, channel surfing). Keep LiveGuideGrid component integration unchanged. Ensure channel switching resets LiveTVSyncPlayer state by using key={selectedChannel.id} on the component. Remove or comment out the old VideoPlayer import and usage for live channels only."
        }
      ]
    },
    {
      "id": "REQ-44",
      "summary": "Handle program transitions in LiveTVSyncPlayer by automatically switching to new program video URL when server indicates program change",
      "acceptanceCriteria": [
        "Component detects program change by comparing current and previous program IDs",
        "Video source switches to new program URL automatically",
        "Player seeks to correct position within new program after source change",
        "Transition appears smooth without visible interruption"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/LiveTVSyncPlayer.tsx",
          "operation": "modify",
          "description": "Add useEffect hook that watches currentProgramId from sync data. Store previousProgramId in a ref to detect changes. When currentProgramId differs from previousProgramId, trigger program transition: fetch the new program's video content using getVideoById with the new currentProgramId, update video source (videoRef.current.src = newVideoUrl), wait for 'loadedmetadata' event, then seek to the playbackPosition from sync data. Show loading overlay during source change. Update previousProgramId ref after successful transition. Handle edge case where program metadata fetch fails by showing error state but continuing to poll for recovery."
        }
      ]
    },
    {
      "id": "REQ-45",
      "summary": "Ensure LiveTVSyncPlayer correctly handles looping scenarios by continuing synchronized playback within looped programs",
      "acceptanceCriteria": [
        "Player correctly seeks to looped position when server returns loop status",
        "Optional UI indicator shows when channel is in loop mode",
        "Looping playback is synchronized across all viewers"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/LiveTVSyncPlayer.tsx",
          "operation": "modify",
          "description": "Check isLooping flag from LiveChannelState in sync response. When isLooping is true, display a small badge or indicator in the player UI (e.g., 'Loop Mode' pill in top-right corner of player). The playbackPosition returned by the server already accounts for looping calculation, so no additional client-side looping logic is neededâ€”just apply the position as normal during drift correction. Add optional isLooping state to component for UI rendering. Style the loop indicator with subtle opacity and positioning to avoid obstructing video content."
        }
      ]
    },
    {
      "id": "REQ-46",
      "summary": "Implement initial sync on channel join by fetching sync data and seeking to current server-calculated position before starting playback",
      "acceptanceCriteria": [
        "Sync data is fetched immediately when channel is selected",
        "Video seeks to calculated position before play() is called",
        "User joins playback at current live position, not from program start",
        "Loading state is shown during initial sync and seek"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/LiveTVSyncPlayer.tsx",
          "operation": "modify",
          "description": "Add initialization logic in useEffect when channelId prop changes. Set isInitializing state to true and show loading spinner overlay. Immediately fetch sync data using getDynamicLiveChannelState(channelId). Extract currentProgramId and playbackPosition from response. Load video source for currentProgram. Wait for 'loadedmetadata' event on video element. Set videoRef.current.currentTime = playbackPosition. Only then call videoRef.current.play(). Set isInitializing to false. Start the polling interval after successful initialization. Handle errors during initialization by showing error message and retry button."
        }
      ]
    },
    {
      "id": "REQ-47",
      "summary": "Preserve existing Live TV features in LiveTVSyncPlayer including ad insertion, disabled forward seeking, and unskippable ad behavior",
      "acceptanceCriteria": [
        "Scheduled ad breaks trigger at correct timestamps during synchronized playback",
        "Forward seeking remains disabled for Live TV content",
        "Unskippable ad behavior works correctly with sync player",
        "All existing Live TV access controls and features remain functional"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/LiveTVSyncPlayer.tsx",
          "operation": "modify",
          "description": "Integrate ad handling logic from existing VideoPlayer: parse adLocations from ScheduledContent in LiveChannelState. Monitor video.currentTime in timeupdate event to detect when playback reaches an ad position timestamp. When ad position is reached, pause main content, switch to ad video source, play ad with unskippable controls (no seek, optional skip after N seconds based on ad assignment settings). After ad completes, restore main content source and resume from correct sync position. Disable seek bar interaction for forward seeking (allow backward seek for premium users if needed, but restrict forward). Check user premium status from useAuth to determine ad display. Add isPlayingAd state to manage ad playback mode and prevent sync corrections during ad playback."
        },
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Ensure useGetAdAssignmentsForLive query hook exists or add it if missing. This hook should call getAdAssignmentsForLive(channelId) and return ad assignment data needed by LiveTVSyncPlayer for displaying ads at scheduled positions. Use React Query's useQuery with queryKey ['adAssignments', 'live', channelId] and enabled flag based on channelId presence."
        }
      ]
    }
  ]
}